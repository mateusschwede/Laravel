"Laravel é a ferramenta perfeita para você possuir abaixo de seu guarda-chuva de soluções"

Novo projeto Laravel, via Composer:
> composer create-project --prefer-dist laravel/laravel projeto1

>>> AULA4 <<<
Projeto3: Automatizando com artisan e resource

> Criar controller com metodos à determinada view automaticamente:
php artisan make:controller Form\TestController --resource --model=User
(--resource cria todos os métodos do controller: verbalização rest e injeções de dependência automaticamente)
(--model=User criará automaticamente toda injeção de dependências dos demais parâmetros relacionados à model User)

> Criar view automatizada universal métodos CRUD
//Criador universal de rotas padrões para o controller TestController(get,post,put/patch,delete), altera o nome da route de 'usuario' para 'user', e altera os parâmetros de uri 'usuarios' para 'user'
Route::resource('usuarios',TestController::class)->names('user')->parameters(['usuarios'=>'user']);

> Alterar nome de trechos da uri para personalizados('original'=>'personalizado')
//Providers > AppServiceProvider.php, método boot()
use Illuminate\Support\Facades\Route;
public function boot() {
    Route::resourceVerbs([
        'create'=>'novo',
        'edit'=>'editar'
    ]);
}

CheckList aula4:
1- Criação automatizada do controller
2- Criação, no routes 'web.php', da route automatizada resources. Tradução dos parâmetros uri na própria route
3- Alimentar views e, ao mesmo tempo, alimentação dos métodos do controller relacionados às mesmas, conforme parâmetros e BD


>>> AULA5 <<<
Projeto4: Versionando BD com Migrations
Ver anotações relacionadas no último arquivo do diretório migrations

Migrations:
Comandos de gestão de BD de dentro do Laravel, usando php
> Up: Comando de envio ao BD (ex: Create table)
> Down: Exatamente o contrário de Up, comando de retorno/desfazer ao BD (ex: Drop table). Down é o método, criado automaticamente, contrário ao criado no Up
Importante que as Migrations sejam criadas em ordem, de acordo com o BD, com relação às tables dependentes. Migrations são executadas em ordem crescente por criação.

Criar Migration:
Comando, no diretório do projeto, via terminal.
Criar nova table(Create Table):
php artisan make:migration comando_nomeTable_table(ex: create_users_table) --create=nomeTable(sintaxe de criação(create) à table nomeTable)

Adicionar novo campo à table existente(Alter Table):
php artisan make:migration comando_nomeTable_table --table=nomeTable

Criar BD após criadas as Migrations:
php artisan migrate (executa todos os arquivos de migrate criados pendentes)

Desfazer criação no BD:
php artisan migrate:rollback (desfaz todas as alterações no BD)
php artisan migrate:rollback --step=2 (No caso, desfazer os últimos 2 passos, ex: desfazer as últimas 2 migrations criadas no BD)

No final, em ambiente empresarial, faço commit de tudo, e a pessoa que trabalhará com o prjeto somente executa o 'php artisan migrate', e todo o BD será gerado/atualizado automaticamente


>>> AULA6 <<<
Projeto5: Criando regra de negócio e configurando Model, manual e automatizado

Para criar Model, primeiro precisa de uma table do mesmo no BD sobre a mesma, criando nova Migration
> Atualizar/Resetar BD com projeto:
php artisan migrate:fresh (exlui tds as tables e recria com base nas Migrations do projeto)

> Criar Migration: php artisan make:migration create_posts_table
>> Após codificar Migration, resetar BD com Migration pendente: php artisan migrate

> Criar Controller: php artisan make:controller PostController
>> Modificar o método welcome em routes 'web.php', com o controller PostController, com método de execução 'showForm'

> Criar método 'showForm' no PostController, em branco

> Criar view de return do 'showForm', chamada 'form.blade.php', e populá-la com Html básico e @csrf

> Criar nova route em 'web.php', do tipo post, com nome e método chamados 'debug'

> No Controller 'PostController', criar método debug só com o inicial, e concluir o 'showForm'

> Inserir action como {{route}} na view 'form.blade.php'

> Popular método 'debug' no controller PostController

> Testar submissão do formulário Hmtl com 'dd($request->al());'

Para inserir os dados do form Html no BD, precisa-se criar a respectiva Model antes.

> Criar Model 'Post':
php artisan make:model Post

> Popular Model 'Post'
Laravel converte tudo para minúsculo e plural ao BD, ou seja, a table relacionada precisa ser 'posts'
1- Informar somente dados relacionados com BD no Controller 'PostController', no método 'debug'(remover o _token...)
2- Informar dados que serão enviados ao Model 'Post' para que possa serem persistidos ao BD(informar no método 'debug' do 'PostController')
Da forma acima, dará erro pq o slug precisa ser não null. Para contornar isso, segue:
> Na Model 'Post', informar e popular o método setPropriedadeAttribute($valorPassadoAtributo) (ex setTitleAttribute($value))
Com isso, automaticamente ao informar o title, ele informará o mesmo como slug, já formatado no formato url, gerados pelo método Str, já informado

> Testar, no formulário Html, a inserção de valores no BD

> (Não recomendável) Pode-se fazer o tratamento de erro de campos e slug de forma mais simples, criando, na Model 'Post', a propriedade fillable
> (Não recomendável) Caso queira remover os campos timestamp() do BD, precisa-se:
1- Remover o atributo na Migration
2- Na Model, inserir atributo 'public timestamps = false;'
3- Atualizar/Resetar BD com comando 'php artisan migrate:fresh'

AUTOMATIZADO
> Criar Model, com Migration e Controller:
php artisan make:model nomeModel -mcr (ex: php artisan make:model Product -mcr)
Após isso, será necessário somente:
1- Preencher campos na migration, de acordo com a respectiva table no DB
2- Informar atributos na Model
3- Informar as routes 'web.php' e programar os métodos no Controller
(Atente-se em informar e verificar os 'use' e 'namespace' corretos para os recursos em cada arquivo)


>>> AULA7 <<<
Projeto6: Relacionamentos entre Models

> Criar Models, com Controllers e Migrations:
php artisan make:model Address -mcr
php artisan make:model Category -mcr
php artisan make:model Post -mcr
php artisan make:controller UserController --resource
(Popular Migrations com atributos)

> Atualizar/Resetar BD: php artisan migrate:fresh

> Inserir, manualmente, alguns Users no BD.
INSERT INTO users(name,email,password,created_at,updated_at) VALUES ('mateus','mateus@gmail',123,now(),now()),('mateus2','mateus@hotmail',456,now(),now());

> Add route usuario/{id} para UserController@show em 'web.php' (informar 'use' tbm)
> Popular método show em UserController (informar 'use' tbm), com $user = User::where('id',$id)->first(); dd($user);
> Testar, informando url no Browser (http://localhost/projetos/laravel/projeto6/public/usuario/1)

> Inserir, manualmente, alguns Addressess no BD.
INSERT INTO addresses(user,street,number,city,state,created_at,updated_at) VALUES (1,'rua x',33,'cidade','rs',now(),now());

> Popular Model Address
(Não serão criadas views com forms, será colocado diretamente via controller(NÃO RECOMENDADO))


Relacionamentos:
1-1: 1 User possui 1 Address
1-N: 1 User possui N Posts
N-N: N Categories possui(em) N Posts


RELACIONAMENTO 1-1 (1User possui 1Address)
Parte-se da table de origem da informação(User, pois User possui Address, Address é dependente de User).

Para saber de qual Address é determinado User (Caminho de ida)
> Em Model User, criar método de relacionamento 'address', que retornará o relacionamento com as keys relacionáveis

> Em UserController, no método show, adicionar método $address
> Testar, informando url no Browser (http://localhost/projetos/laravel/projeto6/public/usuario/1)

Para saber de qual User é determinado Address (Caminho de volta)
> Em route 'web.php', inserir route /endereco/{address}
(Informe 'use' tbm)

> Em AddressController, popular metodo show
> Testar, informando url no Browser (http://localhost/projetos/laravel/projeto6/public/endereco/1)

> Em Model Address, adicionar método user

> Em AddressController, no método show, adicionar método $user
> Testar, informando url no Browser (http://localhost/projetos/laravel/projeto6/public/endereco/1)


RELACIONAMENTO 1-N (1User escreve NPosts)
Processo similar ao acima, só muda o nome do método de relacionamento de keys

Para saber de quais Posts é determinado User (Caminho de ida)
> Inserir, manualmente, alguns Posts no BD
INSERT INTO posts(author,title,slug,content,created_at,updated_at) VALUES (1,'titulo1','titulo1','testeContent',now(),now()),(1,'titulo2','titulo2','testeContent2',now(),now()),(2,'titulo3','titulo3','testeContent3',now(),now());

> Em Model User, criar método de relacionamento 'posts'

> Em UserController, no método show, adicionar método $posts
> Testar, informando url no Browser (http://localhost/projetos/laravel/projeto6/public/usuario/1)
> Testar, informando url no Browser (http://localhost/projetos/laravel/projeto6/public/usuario/2)

Para saber de qual User são determinados Posts (Caminho de volta)
> Em Model Post, propriedade $table e método de relacionamento 'author'

> Em PostController, no método show, echo de volta, somente a linha

> Em route 'web.php', inserir route /artigo/{post}
> Testar, informando url no Browser (http://localhost/projetos/laravel/projeto6/artigo/1)

> Em PostController, método show, informar $user e listagem
> Testar, informando url no Browser (http://localhost/projetos/laravel/projeto6/artigo/1)
> Testar, informando url no Browser (http://localhost/projetos/laravel/projeto6/artigo/2)
> Testar, informando url no Browser (http://localhost/projetos/laravel/projeto6/artigo/3)


RELACIONAMENTO N-N (NPosts possuem NCategories)
Precisa-se de table pivô para fazer a união dos registros(Ex: table posts_categories).

Criar Migration
php artisan make:migration create_posts_categories_table --create=posts_categories
php artisan migrate
(Popular migration tbm)

> Inserir, manualmente, algumas Categories no BD:
INSERT INTO categories(title,description,created_at,updated_at) VALUES ('cat1','descCat1',now(),now()),('cat','descCat2',now(),now());

> Inserir, manualmente, relações entre tables Posts e Categories no BD:
INSERT INTO posts_categories(post,category) VALUES (1,1),(1,2),(2,1),(3,2);

Quais Posts são determinadas Categories(Ida)
> Em Model Category, informar $table
> Em Model Post, informar método de relacionamento categories

Em PostController, no método show, informar $categories e listagem
> Testar, informando url no Browser (http://localhost/projetos/laravel/projeto6/artigo/1)
> Testar, informando url no Browser (http://localhost/projetos/laravel/projeto6/artigo/2)
> Testar, informando url no Browser (http://localhost/projetos/laravel/projeto6/artigo/3)

Quais Categories são determinados Posts(Volta)
> Em route 'web.php', inserir route /categoria/{category}
(Informar 'use' tbm)

> No CategoryController, no método show, informar Html Categories
> Testar, informando url no Browser (http://localhost/projetos/laravel/projeto6/categoria/1)
> Testar, informando url no Browser (http://localhost/projetos/laravel/projeto6/categoria/2)
> Testar, informando url no Browser (http://localhost/projetos/laravel/projeto6/categoria/3)

> Em Model Category, informar método de relacionamento posts
> No CategoryController, no método show, informar Html de Posts
> Testar, informando url no Browser (http://localhost/projetos/laravel/projeto6/categoria/1)
> Testar, informando url no Browser (http://localhost/projetos/laravel/projeto6/categoria/2)
> Testar, informando url no Browser (http://localhost/projetos/laravel/projeto6/categoria/3)


>>> AULA8 <<<
Projeto7: Laravel login com artisan e hardcode

LARAVEL8:
//Criar projeto Projeto7.8 e, dentro do projeto, instalar dependências:
> Com Laravel Installer(laravel new nomeProjeto --jet) Escolher opção de dependência que melhor convém-lhe
> php artisan migrate
> Verificar arquivos e inserir código faltando
> INSERIR BD MANUALMENTE: INSERT INTO user(name,email,password) VALUES ('mateus','mateus@gmail',123);
(O Doc Projeto7.8 mostra o projeto de autenticação incializado, utilizado Laravel8)

Com o lançamento do Laravel8, novas maneiras de autenticação foram desenvolvidas. Elas funcionam por meio do Laravel Jetstream e Fortify, juntamente com serviços de autenticação token API Laravel Livewire e Inertia.js, além de pacotes de autenticação como o Passport Sanctum, ambas libraries baseadas em cookies embutidos no Laravel, onde uma delas deverá ser escolhida para criação do projeto. No entanto, como tudo ainda encontra-se muito novo, instável e pouco padronizado, utilizaremos o meio mais utilizado na versão 6, através do Laravel UI, de uma forma simples com Bootstrap, ao invés do Vue. Isso, além do fato de que desenvolveremos toda a estrutura de login para maior entendimento. Por fim, o processo é bastante similar entre as versões, desde que conheça-se a estrutura e funcionamento da mesma.


> Resetar BD: php artisan migrate:fresh

Instalação Clássica Laravel6 Authentication:
> composer require laravel/ui --dev
> php artisan ui bootstrap --auth
> npm install && npm run dev (necessário Node.js instalado!)
(Serão geradas migrations, route, controllers e views específicas para authentication)

> Testar no Browser se a página possui botões de Login/Register (http://localhost/projetos/laravel/projeto7/public)
(Entrar na página 'Register' e registrar novo User, senha de pelo menos 8 caracteres, Testar login com os mesmos dados)

Criando Painel de Administração Manualmente:
> Em routes 'web.php', adicionar route comentada /admin (Descomentar após feitos respectivos Controller e método envolvidos)

> Criar controller AuthController: php artisan make:controller AuthController
> Criar método dashboard no AuthController

> Criar, em views, diretório admin
> Em views/admin criar View dashboard
> Testar no Browser (http://localhost/projetos/laravel/projeto7/public/admin)

> Inserir, dentro do método dashboard do AuthController, condição if da facade Auth
(Insira os 'use' tbm)
> Em routes 'web.php', adicionar route /admin/login
> Em AuthController, inserir método showLoginForm
> Em views/admin, adicionar view formLogin
> Em AuthController, informar return redirect
> Testar no Browser (http://localhost/projetos/laravel/projeto7/public/admin) será redirecionado à /login

Validar iserção dos dados e exibir dashboard:
> Em routes 'web.php', informar route '/admin/login/do'
> Em AuthController, informar método login com somente dd()
> Testar formulário no Browser F5

> Em AuthController, método login, informar $credentials e Auth::attempt()
> Testar login, conforme BD, no Browser (http://localhost/projetos/laravel/projeto7/public/admin/login) e, após isso voltar para /admin, encontrarei o painel de admin

> Em AuthController, informar no if dd(Auth::user)

Logout:
> Em routes 'web.php', informar route '/admin/logout'
> Em AuthController, informar método logout
> Em view dashboard, informar link com route logouts
> Testar login, conforme BD, no Browser (http://localhost/projetos/laravel/projeto7/public/admin/login) e, após isso clicar em 'logout'(voltará ao form de login)

Validar Erros:
> AuthController, informar if Auth::attempt e return redirect back
> Em view formLogin, informar @if
> Testar login incorreto no Browser (http://localhost/projetos/laravel/projeto7/public/admin/login)

Validar email:
> Em view formLogin, trocar a propriedade email para text no input email
> AuthController, método login, informar if filter_var $request->email
> Testar email login incorreto no Browser (http://localhost/projetos/laravel/projeto7/public/admin/login)


>>> AULA9 <<<
Projeto8: Laravel Frontend com Blade

- Diretivas sintáticas específicas do Blade(if, foreach, while...)
- Caracteres de interpolação(interpolation, misturar Html com Php de forma mais simples)
- Assets: Ativos do site(js, css...)

> Em routes 'web.php' criar routes /cursos e /contato, inserindo name() nas routes, e alterar view 'welcome' para 'site.home'
> Em views, criar diretório 'site' e, dentro dele, criar view home
> Acessar site do Bootstrap > Examples > Carousel, acessar código fonte, copiar todo o <body> até o </main>, colar o código na view 'home' e fechar o </body>
> No Browser, página 'public', recarregar página e testar site

Interpolation (Mesclar Php com Html usando o Blade):
> Em view 'home', alterar, no footer, o ano para Php {{date('Y')}}

Diretivas (@if, @foreach, @while...):
> Em view 'home', inserir if de condição bom dia, boa tarde, boa noite (Aprox linha 47) e foreach modelo
> Em Config/app.php, alterar timezone para 'America/Sao_Paulo' (UTC é o padrão do Laravel, 3 hrs a mais...)
> No Browser, página 'public', recarregar página e testar site
Exemplo:
@foreach()
    <p>Código aqui</p>
@endforeach

Criar página de contato:
> No navbar, criar links de routes para os itens home, cursos e contato(retirar 'disable' do contato)
> Criar views, no diretório site, 'contact' e 'courses'

Herança (@extends: Layout Filho herda de Layout Master):
> No diretório 'site', criar diretório 'master'
> Em 'master', criar view 'layout'(Layout Master). Recortar todo conteúdo da view 'home' na view 'layout'
> Em view 'home' informar @extends

> Em view 'layout', informar links de routes nos itens do navbar
> Em routes 'web.php', alterar routes /cursos e /contato de view 'welcome' para suas respectivas views

> Em view 'layout' recortar conteúdo de <main> até </main> (Mas manter o footer, tag main deve ser mantida)
>> Dentro da tag main informar @yield('content')
> View 'home', informar @section('content'), colar conteúdo recortado de layout abaixo da section, após informar @endsection
>> Testar, no Browser, página home e verificar se o conteúdo interno fora acoplada à mesma(Páginas courses e contact possuem somente conteúdos extendidos de 'layout')

> View 'contact', informar @section('content') e @endsection e conteúdo interno à ela
>> Testar, no Browser, página contact e verificar se o conteúdo interno fora acoplada à mesma

> View 'courses', informar @section('content') e @endsection e conteúdo interno à ela
>> Testar, no Browser, página courses e verificar se o conteúdo interno fora acoplada à mesma

Menu itens ativos/selecionados:
> View 'layout', em nav-item do navbar, informar condição ternária {{Route...}}


>>> AULA 10 <<<
Projeto9: Gerenciando Assets com Laravel Mix
Laravel Mix: Ferramenta do ecossistema Laravel para gestão de webpacks

Codificação diretório site:
> Diretório 'views', criar novo diretório 'site', criando dentro desse uma view 'home'
>> Diretório 'site', criar novos diretórios 'css' e 'js'
>>> Diretório 'css', criar arquivo 'style.css'
>>> Diretório 'js', criar arquivo 'script.js'

Instalar dependências de acesso à arquivos que não estão no diretório public:
> npm install (Instalará todas dependências presentes no arquivo package.json) - Necessário Nodejs com NPM instalados
(Criará diretório 'node_modules', contendo todas dependências js)

Parametrizar arquivos css que serão vinculados ao diretório 'public':
> Arquivo 'webpack.mix.js', comentar entradas e informar mix styles
>> npm run dev (Atualizar arquivos com mix, gera arquivo de destino no diretório 'public')

> Em 'views/site/css/style.css', inserir estilos para *
(Sempre alterar arquivos no 'resources', os de 'public' serão gerados automaticamente à partir destes)
>> Atualizar arquivos mix: npm run dev (npm run produtcion mimifica tbm)

Inserir novo arquivo de css para parametrizar:
> Em views/site/css criar novo arquivo 'reset.css', recortar conteúdo do 'style.css' e colar no 'reset.css'
>> Em views/site/css/style.css, informar estilos de h1
>> Em 'webpack.mix.js' informar, no caminho de origem, arquivo 'reset.css'
>> Atualizar arquivos mix: npm run dev (npm run produtcion mimifica tbm)
(npm run dev resultará em 1 único arquivo no public, com todos código concatenados, em ordem, dos arquivos origem)
(npm run produtcion fará o mesmo que npm run dev, mas colocará o código, no arquivo destino, em única linha)

Vincular arquivos css com view home:
> View 'home', informar <link> com asset, que linkará arquivos no diretório 'public'
> Em routes 'web.php', alterar route '/'
>> Testar, no Browser, url padrão de entrada (http://localhost/projetos/laravel/projeto9/public)

Otimizar chamada de arquivos origem/destino, para melhor compatibilidade com futuras atualizações de versões css e js:
> Em 'webpack.mix.js', informar .version() no mix.styles
>> Atualizar arquivos mix: npm run produtcion (Gerará, em public, arquivo 'mix-manifest.json', com link Hash de versão do css e js)
>> Linkar Hash na view home: View 'home', alterar link asset por url(mix)

Parametrizar arquivos js que serão vinculados ao diretório 'public':
> Em 'views/site/js/script.js' popular arquivo com alert
> Em 'webpack.mix.js', criar mix.scripts e informar caminhos
>> Atualizar arquivos mix: npm run produtcion

Vincular arquivos js com view site home:
> View 'site.home', informar <script> com url(mix)
>> Testar, no Browser, url padrão de entrada (http://localhost/projetos/laravel/projeto9/public)

Automatizar atualização dos arquivos mix:
npm run watch (Lê arquivos e assite-os. Qualquer modificação nos arquivos, o npm fará a atualização automaticamente)

> Em views/site/css/style.css, alterar tamanho de fonte
>> Testar, no Browser, url padrão de entrada (http://localhost/projetos/laravel/projeto9/public)

Codificação diretório admin:
> Em diretório views, criar novo diretório 'admin'
>> Diretório admin, criar novos diretórios 'css' e 'js'
>> Diretório admin, criar view 'home'
>>> Em routes 'web.php', criar route '/admin'
>>>> Testar, no Browser, url admin de entrada (http://localhost/projetos/laravel/projeto9/public/admin)

Criar css do admin:
> Em 'views/admin/css' criar arquivo 'style.css'
> Em 'views/admin/js' criar arquivo 'script.js'

Vincular arquivos com diretório public:
> Em 'webpack.mix.js', acrescentar novos mix.styles() e mix.scripts()
>> Matar processo de watch: cntrl+c no terminal
>> Rodar watch novamente para sincronizar: npm run watch

Vincular css e js com view admin home:
>> View 'admin.home', informar <link css> e <script> com url(mix)
>>>> Testar, no Browser, url admin de entrada (http://localhost/projetos/laravel/projeto9/public/admin)
(Proibirá o acesso - conflito entre routes e diretórios (Caminho da route e diretório com mesmo nome))

(Resolver alterando o caminho da route, ou nome do diretório)
> Mudar nome do caminho da route '/admin' para '/painel'
>> Testar, no Browser, nova url admin de entrada (http://localhost/projetos/laravel/projeto9/public/painel)


>>> AULA11 <<<
Projeto10: Bootstrap local no Laravel

> Criar view 'home'
> Em routes 'web.php', alterar route 'welcome' para 'home'

Instalação das dependências:
> Instalar, no diretório do projeto, jQuery via terminal usando npm: npm install jquery
(Diretório node_modules será criado com dependências js)

Vincular jQuery com o public do projeto:
> Arquivo 'webpack.mix.js', apagar/comentar mix padrão e criar novo mix.scripts
> Vincular com public: npm run dev

Implementar jquery dentro da view 'home':
> View 'home', informar <script> com asset

> Instalar Bootstrap no projeto: npm install bootstrap
(Diretório bootstrap será criado em node_modules)
> Arquivo 'webpack.mix.js', criar mix.scripts do bootstrap
> Vincular com public: npm run dev

> Arquivo 'webpack.mix.js', criar mix.sass do bootstrap acima do mix.scripts
(Poderia-se vincular somente os arquivos .css no dist do Bootstrap para usar o framework comum, mas não poderia-se criar estilos próprios)
> Vincular com public: npm run dev (2x se necessário para instalação de outras dependências)

Implementar bootstrap dentro da view 'home':
> View 'home', informar <script> do Bootstrap, e <link css> do Bootstrap(Acima dos <script>) e conteúdo Html de teste
>> Testar, no Browser, informando url padrão(http://localhost/projetos/laravel/projeto10/public/)

Alterar propriedades do Bootstrap (Personalização):
> Diretório 'views', criar novo diretório 'scss' e, dentro desse, criar arquivo 'style.scss'
>> Em 'webpack.mix.js', recortar caminho de origem do mix.sass, e colar dentro de um @import do style.scss
> Em 'webpack.mix.js', em mix.sass, informar novo caminho de origem com relação ao arquivo style.scss em views. Modificar o nome dor arquivo de saída de bootstrap para style.css
> Vincular com public: npm run dev
(Apagar arquivo antigo public/site/bootstrap.css)

Atualizar vinculação com view 'home':
> Em view 'home', alterar <link css> do bootstrap para novo arquivo(style.css)

Alterar o Theming(Vars de Personalização) do Bootstrap:
> Adicionar novo padrão de cor(Theme Colors)
> Em 'resources/views/scss/style.scss', informar Theme Colors informando cores personalizadas
> Vincular com public: npm run dev
> Na view 'home', informar button de class danger
>> Testar, no Browser, informando url padrão(http://localhost/projetos/laravel/projeto10/public/)


>>> AULA12 <<<
Projeto11: Uploads automatizados no Laravel

Pré-Requisitos:
> Criar Migration CreateProductsTable: php artisan make:migration create_products_table --create=products (Informar dados tbm)
> Criar Migration CreateProductsImagesTable: php artisan make:migration create_products_images_table --create=products_images (Informar dados tbm)
>> Resetar BD: php artisan migrate:fresh
> Criar Models Product e ProductImage

UPLOAD SIMPLES
> Em 'views', criar diretórios 'upload' e 'products', em 'upload' criar view 'form'
> 'web.php' criar route 'form'
>> Testar, no Browser, url (http://localhost/projetos/laravel/projeto11/public/form)

> Cria controller UploadConttroller: php artisan make:controller UploadConttroller
>> UploadConttroller, criar método upload, em branco(informar 'use' tbm)
>> 'web.php', criar route 'upload'
>> View 'form', informar action 'route()'
>> UploadConttroller, popular método upload com 'dd()'
>>> Testar, no Browser, uma submissão

> UploadConttroller, método upload, informar $request->file()->store(), comentar 'dd()'
(No Laravel, arquivos são salvos na pasta 'storage', gerenciado pelo arquivo config>filesystems.php, 'default'. A filesystem_driver está configurada, ou não, no arquivo .env. Se não existir, utilizará a 'local', configurada em 'disks', abaixo no mesmo arquivo)

Criar filesystem_driver como public, para ser acessada:
> Em .env, abaixo de LOG_CHANNEL, informar FILESYSTEM_DRIVER=public
(Agora, de acordo com filesystems.php, os arquivos upload serão salvos em 'storage/app/public')
(De acordo com UploadConttroller, método store, ao fazer upload, o arquivos será salvo em 'storage/app/public/pastaTeste')
>> Testar, no Browser, uma submissão(Verificar se diretório e upload fora feito)

UPLOAD MÚLTIPLO e BD
> Criar controller ProductController: php artisan make:controller ProductController --resource

> Em views/products criar views create e show
>> ProductController, popular método create

> 'web.php', criar route resource('produtos')(informar 'use' tbm)
> Verificar se traduziu names: php artisan route:list
>> Testar, no Browser, url(http://localhost/projetos/laravel/projeto11/public/produtos/create)

> ProductController, popular método store com 'dd()'
>> Testar, no Browser, submissão de 2 arquivos
> ProductController, popular método store parte de Add Product, comentar 'dd()'(Informar 'use' tbm)
>> Testar, no Browser, submissão de 2 arquivos(Verificar se gravou no BD)

> ProductController, popular método store parte de Add Image(s), com 'var_dump()' no for e no início
>> Testar, no Browser, submissão de 2 arquivos

> ProductController, popular método store parte de Add Image(s), comentar var_dumps(Informar 'use' tbm)
>> Testar, no Browser, submissão de 2 arquivos(Verificar se gravou no BD)

> ProductController, popular método show
>> Testar, no Browser, url(http://localhost/projetos/laravel/projeto11/public/produtos/4)

> Em .env, APP_URL, informar url do projeto(http://localhost/projetos/laravel/projeto11/public)
> Atualizar Laravel url de storage à Public: php artisan storage:link
>> Testar, no Browser, url(http://localhost/projetos/laravel/projeto11/public/produtos/4)


>>> AULA13 <<<
Projeto12: Ajax no Laravel
(Baseado no Projeto7, Laravel6 login)

Pré-Requisitos:
> Resetar BD: php artisan migrate:fresh
> Inserir user no Register

> Atualizar jQuery, informando link na view 'formLogin', inserir tbm arquivo Ajax(https://github.com/jquery-form/form), informando link CDN
>> No final do código, informar área de código(<script>) com função Ajax, com alert teste
>> Testar no Browser(http://localhost/projetos/laravel/projeto12/public/admin/login)
>> Remover method e action do form, e informar name no <form>
>> Inserir função de submissão, com alert teste2 e testar, no Browser, submissão
>> Inserir vars do form e testar, no Browser, submissões com os alerts
>> Comentar vars, inserir função $.ajax

> Controller AuthController, alterar if de feedback de validação de email
>> Da mesma forma, informar no if Auth::attempt e abaixo, fora, dele
>>> Testar, no Browser, informando email inválido e dados inválidos(Verificar console se json fora informado)

> View formLogin, alterar, na $.ajax, console por resposta
>> Remover blocos @if e @foreach, bloco {{$error}} também. Alterar class da <div>
>> Função $.ajax, abaixo do else para erro, informar messageBox
>>> Testar, no Browser, informando dados inválidos(verificar se mensagem <div> aparecerá)
>>> Testar, no Browser, informando dados corretos(verificar se será redirecionado)


>>> AULA14 <<<
Projeto13: Enviando emails no Laravel

Pré-Requisitos:
> Arquivo .env, parte de mail, configurar autenticação com servidor(Recomendável servidor de hospedagem/compartilhado premium para que o email não caia em span)
> Se seu remetente for Gmail, ative a opção de segurança 'Acesso a app menos seguro', nas configurações de sua conta Gmail

> Criar objeto de email: php artisan make:mail newLaravelTips(nomeClasse)(No diretório app, cria-se diretório Mail)
> Em routes 'web.php', informar route 'envio-email'

Criar views de teste template de email:
> Em 'views', criar diretório 'mail', com view 'newLaravelTips' e populá-la
> Em classe newLaravelTips, método build, alterar nome da view de retorno
>> Testar, no Browser, url (http://localhost/projetos/laravel/projeto13/public/envio-email)

> Classe newLaravelTips, popular método build com parâmetros
> Views 'web.php' popular view 'envio-email' com objeto std e parâmetros
> Classe newLaravelTips, informar parâmetro $user no método construct, populá-lo, e atributos acima dele

Disparar email teste:
> View newLaravelTips, informar vars{{}}
>> Testar, no Browser, se variáveis foram informadas, url(http://localhost/projetos/laravel/projeto13/public/envio-email)
> web.php, comentar return new, e informar Facade Mail
>> Testar, no Browser, se variáveis foram informadas, url(http://localhost/projetos/laravel/projeto13/public/envio-email)
>>> Verificar caixa de entrada e span no email destinatário

Criar template markdown de Email:
Importar templates markdown personalizáveis de email do Laravel: php artisan vendor:publish --tag=laravel-mail
(Em resources/views cria-se diretório 'vendor/mail' com temas e configuráveis)
> web.php, comentar linha de Mail send() e descomentar linha acima, de return
>> Testar, no Browser, recarregar págnina, se view é mostrada novamente(http://localhost/projetos/laravel/projeto13/public/envio-email)

> Classe newLaravelTips, alterar return this->view para markdown(Comentei linha antiga e informei nova abaixo)
>> Testar, no Browser, se layout mudou(http://localhost/projetos/laravel/projeto13/public/envio-email)
> View newLaravelTips, informar @component e @endcomponent
>> Testar, no Browser, se layout mudou(http://localhost/projetos/laravel/projeto13/public/envio-email)

Disparar email pronto:
> web.php, comentar return e descomentar Mail send()
>> Testar, no Browser, envio do email(http://localhost/projetos/laravel/projeto13/public/envio-email)
(Verificar na caixa de email/span do email destinatário)


>>> VER AULA15 <<<
Projeto14: Fila e Processamento Assíncrono no Laravel
(Replica do projeto13)

Ideia é enviar requisições ao BD, para depois executá-las, ao invés de executar tudo no momento

Parametrizar o projeto para trabalhar com fias:
> web.php, alterar método send() para queue()
> Em .env, alterar QUEUE_CONNECTION para modo 'database'

Parametrizar BD para queue:
> Adicionar table específica no BD: php artisan queue:table (Cria migrations específicas: jobs e failed_jobs)
> Atualizar BD: php artisan migrate:fresh
>> Testar, no Browser, se carregamento da página ficou mais rápido(http://localhost/projetos/laravel/projeto14/public/envio-email) (Cntrl+c para parar)
(Execuções de emails salvos na table jobs)
> Executar fila: php artisan queue:work

Criar agendamentos/programações de tarefas(Jobs):
> Criar objeto job: php artisan make:job newLaravelTips
(Em app, cria-se diretório 'jobs', com classes dentro)
> web.php, alterar método queue por send() novamente, e recortar linha da classe job newLaravelTips, método handle
> web.php, informar dispatch()
> Classe job newLaravelTips, popular método construct, criar atributo acima
> Executar fila: php artisan queue:work
>> Testar, no Browser, submissão(http://localhost/projetos/laravel/projeto14/public/envio-email)
(Após delay, no caso 15seg, jobs são processados e, se der falha, tenta, no caso, faz até 3 tentativas no total)


>>> AULA16 <<<
Projeto15: Autenticação com Socialite(Google,Facebook) no Laravel

Pacote para autenticação com outros servidores(Google, Facebook...). Os processos tendem a ser iguais, com excessão das nomeoclaturas
O ideal, além disso, é criar, após isso, uma regra de negócios para salvar a autenticação em BD, para então não depender somente dos dados terceiros e sessões fictícias

Pré-Requisitos:
> Pesquisar na documentação o Laravel Socialite
> Facebook for Developers
> Google Integrating
> Instalar componente Socialite: composer require laravel/socialite

Configurar Socialite:
> Diretório config, services.php, inserir trecho de configuração 'facebook'
> Arquivo .env, informar todas as chaves do trecho de configuração 'facebook', no final do arquivo(Valores serão informados em breve)

FACEBOOK
Página Facebook Developers:
> Meus Apps / Criar novo: Pegar id do app gerado e colá-lo no FACEBOOK_CLIENT_ID
> Configurar, na página, em Facebook Login / Web, infrmar url(http://localhost/projetos/laravel/projeto15/public/), avançar até finalizar as etapas(Nada mais será necessário, somente avançar)
> Em configurações/basico, copiar chave secreta e colá-la no FACEBOOK_CLIENT_SECRET, informar domínio(localhost) e url's de privacidade e termos de uso(da sua aplicação/github como exemplo), tipo de uso comercial(Apoia minha própria empresa) e salvar alterações

Criar routes:
> Criar controller SocialiteController: php artisan make:controller SocialiteController
> Em SocialiteController, informar métodos(Informar 'use' tbm)
> Em routes 'web.php', informar routes(Informar 'use' tbm)
>> Testar login, no Browser, informando url(http://localhost/projetos/laravel/projeto15/public/login/facebook), clicar em 'continuar', e um erro 404 de feedback aparecerá
> Em .env, alterar APP_URL com url informada(http://localhost/projetos/laravel/projeto15/public)
>> Testar login, no Browser, novamente(http://localhost/projetos/laravel/projeto15/public/login/facebook), cairá em uma página em branco

GOOGLE
> Diretório config, services.php, inserir trecho de configuração 'google'
> Arquivo .env, informar todas as chaves do trecho de configuração 'google', no final do arquivo(Valores serão informados em breve)
> Em SocialiteController, informar métodos Google
> web.php, informar routes google
Página Google Developers Console:
Credenciais / Criar Credenciais / ID do Cliente OAuth / Tipo de Aplicativo(App da web) / Nome(Laravel Socialite) / Origens JS autorizadas(http://localhost) / URLs de Redirecionamento Autorizados(http://localhost/projetos/laravel/projeto15/public/login/google)(http://localhost/projetos/laravel/projeto15/public/login/google/callback) / Create
> Copiar id e chave, colá-los no .env do Google
>> Testar login, no Browser, informando url(http://localhost/projetos/laravel/projeto15/public/login/google)


>>> AULA17 <<<
Projeto16: Sessões com Helper e Facade no Laravel

Configurar sessão:
> Em config/session.php e .env alterar SESSION_DRIVER de 'file' para 'cookie'

> Criar controller SessionController: php artisan make:controller SessionController
> SessionController, criar método session(Informar 'use' tbm) com somente dd()
> Em routes 'web.php', criar route session(Informar 'use' tbm)
>> Testar, no Browser, se route funciona(http://localhost/projetos/laravel/projeto16/public/session)

Gravar dados na sessão:
> SessionController, método session, popular método e testar, no Browser, mesma url
>> Testar, no Browser, echos de sessão(http://localhost/projetos/laravel/projeto16/public/session)
(1ª vez confira flash, comente a Session::flash, depois recarregue a página novamente(ainda à exibirá), depois novamente(sumirá))